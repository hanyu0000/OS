# 特权级
建立特权机制是为了通过特权来检查合法性,0 级特权是我们操作系统内核所在的特权级。计算机在启动之初就以 0 级特权运行，MBR 是咱们所写的第一个程序
### TSS(Task State Segment)任务状态段
TSS 是一种数据结构，它用于存储任务的环境。

特权级转移分为两类，一类是由中断门、调用门等手段实现低特权级转向高特权级，另一类则相反，是由调用返回指令从高特权级返回到低特权级，这是唯一一种能让处理器降低特权级的情况。

TSS 也是一样，它是由 TR（Task Register）寄存器加载的，每次处理器执行不同任务时，将 TR 寄存器加载不同任务的 TSS

在实模式下，段基址直接写在段寄存器中，而在保护模式下，段寄存器中的不再是段基址，而是段选择子，通过该选择子从 GDT 或 LDT 中找到相应的段描述符，从该描述符中获取段的起始地址

计算机中，具备“能动性”的只有计算机指令，只有指令才具备访问、请
求其他资源的能力，指令便是资源的请求者

处理器的当前特权级是 CS.RPL

在 CPU 中运行的是指令，其运行过程中的指令总会属于某个代码段，该代码段的特权级，也就是代码段描述符中的 DPL，便是当前 CPU 所处的特权级，这个特权级称为当前特权级，即 CPL （CurrentPrivilegeLevel），它表示处理器正在执行的代码的特权级别。
# 函数调用约定
cdecl 的调用约定:

（1）调用者将所有参数从右向左入栈

（2）调用者清理参数所占的栈空间
# linux系统调用
系统调用是 Linux 内核提供的一套子程序,系统调用的入口只有一个，即第 0x80 号中断

BIOS 中断走的是中断向量表，所以有很多中断号给它用，而系统调用走的是中断描述符表中
的一项而已，所以只用了第 0x80 项中断

系统调用的子功能要用 eax 寄存器来指定

调用“系统调用”有两种方式

（1）将系统调用指令封装为 c 库函数，通过库函数进行系统调用，操作简单

（2）不依赖任何库函数，直接通过汇编指令 int 与操作系统通信。

>跨过库函数直接与系统内核通信，这样最终的程序不需要与任何库文件链接，这是获得系统功能效率最高的方式

当输入的参数小于等于 5 个时，Linux 用寄存器传递参数。
当参数个数大于 5 个时，把参数按照顺序放入连续的内存区域，并将该区域的首地址放到 ebx 寄存器

我们只考虑参数小于等于 5 的情况:(根目录下的syscall_write.S文件)

eax 寄存器用来存储子功能号（寄存器 eip、ebp、esp 是不能的）

5 个参数存放在以下寄存器中，传送参数的顺序如下

（1）ebx 存储第 1 个参数

（2）ecx 存储第 2 个参数

（3）edx 存储第 3 个参数

（4）esi 存储第 4 个参数

（5）edi 存储第 5 个参数

在汇编代码中导出符号供外部引用是用的关键字 global，引用外部文件的符号是用的关键字extern

在 C 代码中只要将符号定义为全局便可以被外部引用（一般情况下无需用额外关键字修饰，引用外部符号时用 extern 声明即可）
# 内联汇编
内联汇编称为 inline assembly，GCC 支持在 C 代码中直接嵌入汇编代码，所以称为 GCC inline assembly